# Simple-Shell
## Goal
The goal of this project is to understand important UNIX system calls by implementing a simple shell called sshell. A shell is a command-line interpreter: it accepts input from the user under the form of command lines and executes them.

## High level idea of the program design:
The simgple shell implementation can be divided into four components : The Prompt, The Parser, The Executor and The shell background
### The Prompt 
The Prompt first print the shell prompt such as "shell$: " and wait until it reads the command line after user input <Return>. Then we removing tailing newline from command line.
### The Parser 
The Parser collect command line and parse it with the following special characters: "|" ,"&"," ","<",">" sequentially and hierarchically. The Parser check if the commandl line is valid and output error if the commandl line is invalid. The valid parsing result will be put into a data structure called Command and link all the pipeline program as linked list if necessary. The Command data structure will store the commands and other needed arguments that will be executed. 
### The Executor 
The executor will take the command data structure generated by the Parser and create a child process for every single command in the linked list. It will handle if any builtin function are asked for. The related function is cmdHandler(). It will also create pipes file descriptor if necessary to communicate the output of one process to the input of the next one. Moreover, if there are any redirections, it will redirect the Stdout and Stdin to the specific files. The related functions are execute() and executepipe(). The execute() will be called if there is only single command in command line and the executepipe() will be called if there is pipeline command. 
### The Shell background 
The shell background is a data structure that organize all the foreground and background commands as linked list. If we don't have any other processes, current command is the head of processes' linked list. If we have other active processes, we add current command into the tail of the linked list and build command as pipe structure. Additionaly, it will keep tracking if any commands has finished and collect its exit status. Before the prompt print the "shell& " and read command line, the shell first check if there is any finished command process,remove every zombie process and print complete statement exit status. The related method in program is "executeStatus".

Specific implementation details about executePige,execute,ExecStatus and myCmdHandler will be discussed in the implementation details with respect to each phase. 
## Implementation details:
This assignment are divided into 8 phases and each phases add new shell features based on the previous one. We tested the shell program at each phase to check if the shell satisfied the requirement criteria and continued on next phase 
- Phase 1

Regarding to the phase 1,Our shell is built based on the single shell skeleton ( fork()+execu()+wait() )from lecture. We handle the information message following the execution of the command using printf(stderr, ...) and input &status pointer into wait(pid,status) in order to obtain the exit value for the child process and print competed statement as child process exit. If the child processes have all exit and finished, we will set the FINISHED flag in the command data structure to true and interpret it as completed commmand.
- Phase 2 and Phase 3

Regarding to phase 2 and phase 3, in order to be interactive, we read commands from user and execute them. We use fget() function to collect user inputs. When dealing with commands that read from the input and arguments that user inputs with specific program, our group designed a Command data struture in order to handle command parsing and store values for the single command.In the command struct, we store command line input, all the comand arguments, number of arguments, specific program name, in_direct file name, out_direct name, FAIL variable indicating command constructor succeed or fail, PID for command as well as exit status of the command. Overall goal of this design is trying to abstract "features" out of single command, using encapulation to reduce redundent code while tring to obtain states and results of commands. The parsing implementation is inside method command_init of command struct at that time.In method command_init, we parse arguments individually into tempArgs and store command name into field called program. Most importantly, it reduces more complicated user command line which we encountered in phase 6 and 7 down to the single command problem. As it will detect "<" and ">" when parsing command line and store input or output file into field, in_direct or out_direct, opening the appropriate files. Later when implementing phase 6 and 7, we can simply replace stdin and stdout with files indicated by those two files. As discussed in high level idea, specific execution happens inside execute function. If it is not built in, it will call execvp running in the child process. While errors messages mostly occurred when parsing commands, if it happened when building command struct, struct will not be constructed and print error message. if it happened when executing, process will exit with 1 and print error messages.
- Phase 4

Regaring to phase 4, we use function myCmdHandler to handle 3 builtin function's implementations. Inside of this function, we use switch statements to choose different functionalities. During execution, the executor will first check if the command is built in. It it is built in command, it will use cmdhandler() and output its exits status. If it is not built in command, we will create child process as usual.

- Phase 5 and 6

Regarding to phase 5 and 6, as described in struct command, file names will be stored inside of either in_direct or out_direct field of command by the parser. In execute function, we use dup2() to replace stdin and stdout with in_direct or out_direct filenames, then executing as phase 2 and 3.

- Phase 7

Regarding to phase 7, we designed another data structure called pipe using struct. Pipe, while building its structure, it parses user input using strtok, storing each command as linked list. During the parsing, it will also check whether the command line is background. Inside of executePipe function, it assembles execute function, instead it loops through the command array. Replacing stdin or out with infile or outfile, it uses execvp to execute non-built in and myCmdHandler for the built-in. 

- Phase 8 

Regarding to phase 8, since the number of background commands is not fixed, we used linked list on our data structure pipe. Use again the parser to detect if there is "&" at the end of the command. In terms of the background command, we execute as normally but stored it into the command background linked list instead of waiting it until completed. The FINISHED flag for background process sets to true only they are completed. The way of how we check if the background process has terminated is that we use waitpid( pid,status,WNOHANG). If WNOHANG was specified in options and there were no children in a waitable state, then waitid() returns 0. 
Before printing the completed statements, we have the ExecStatus to check if any command has finished. we have the following code:

```
			// Collec child program pid
			mypipe->commands[0]->pid = pid;
			// parent process, waits for child execution
			if (!mypipe->background){
				waitpid(pid,status,0);
				mypipe->commands[0]->status = WEXITSTATUS(status);
				mypipe->FINISHED = true;
			}
```
Therefore, in the parent process, if a command has a background field true, it doesn't have to wait until the child process finishes. It will run in the background when new prompt being updated. As described in the high level idea,  we use executeStatus to manage the new process into the linked list. Background process if active will be stored in the linked list. executeStatus will manage processes inside of the linked list by checking their pointers, if some become null, the zombie process nodes will be removed from the linked list. Global variable "activeJobs" keeps track of number of active nodes in the linked list. If there is only one node of the linked list, myCmdHandler can take "exit" and exit the shell. Each pipe type has the field of finished and cmdCount. When a pipe finishes all its commands, it is finished. It will print out complete statement with all its commands' statuses. While loop inside of executeStatus will guarantee all the finished commands in the linked list have been removed. 

### Citation details
1. Different strings can be parsed concurrently using sequences of calls to strtok_r() that specify different saveptr arguments. The reason that we did not use strtok when parsing is not thread safe.
https://stackoverflow.com/questions/15961253/c-correct-usage-of-strtok-r
2. Understand how strtok works and effects when put string input as its parameters.  
https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm
3. Understand how waitpid workds and the available option we can use  
https://www.tutorialspoint.com/unix_system_calls/waitpid.htm 

4. Understand how to construct linked list data structure in C

	https://www.learn-c.org/en/Linked_lists 

5. Understand how to use struct to build data structure in C

	https://www.rose-hulman.edu/class/cs/archive/csse120-old/csse120-old-terms/201030robotics/Slides/Structs.pdf 

